# -*- coding: utf-8 -*-
"""Untitled0.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1aDIa_jrjrJEEMCOmL6UliAhWwf3t-r4Q
"""

!pip install torch_geometric

import torch
from torch_geometric.utils import to_networkx
from torch.nn import Linear
from torch_geometric.nn import GCNConv, global_mean_pool
from torch_geometric.data import Data, DataLoader

import networkx as nx
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
import ast
import re

"""# Data Processing"""

df = pd.read_csv("/content/N1-7_total.csv")

# Data processing
n_list = df['N']
adj_list = df['adj']

dataset = []

for i in range(len(df)):
  # convert string into adjacency matrix
  numbers = list(map(float, re.findall(r"[-+]?\d*\.\d+|\d+", adj_list[i])))
  adj_input = np.array(numbers).reshape(n_list[i], n_list[i])
  adj_matrix = torch.tensor(adj_input)

  # convert adjacency matrix into edge_index
  edge_index = adj_matrix.nonzero().t().contiguous()

  # create labels
  y = torch.tensor([df['runtime'][i]], dtype=torch.float)

  # create Data object
  data = Data(edge_index=edge_index, x=torch.ones((n_list[i], 1), dtype=torch.float), y=y, num_nodes=n_list[i])

  # add to dataset
  dataset.append(data)

G = to_networkx(data, to_undirected=True)
plt.figure(figsize=(12,12))
plt.axis('off')
nx.draw_networkx(G)
plt.show()

input_size = 1 # number of node features
output_size = 1

class GCN(torch.nn.Module):
    def __init__(self):
        super().__init__()
        self.gcn1 = GCNConv(input_size, 64)
        self.relu1 = torch.nn.ReLU()
        self.gcn2 = GCNConv(64, 64)
        self.relu2 = torch.nn.ReLU()
        self.lin = torch.nn.Linear(64, output_size)

    def forward(self, data):
        x, edge_index, batch = data.x, data.edge_index, data.batch
        x = self.gcn1(x, edge_index)
        x = self.relu(x)
        x = self.gcn2(x, edge_index)
        x = self.relu(x)
        x = global_mean_pool(x, batch)
        x = self.lin(x)
        return x

model = GCN()
print(model)

optimizer = torch.optim.Adam(model.parameters(), lr=0.001)
loss_fn = torch.nn.MSELoss()

import random
random.shuffle(dataset)

train_dataset = dataset[:5000]
test_dataset = dataset[5000:]

train_loader = DataLoader(train_dataset, batch_size=64, shuffle=True)
test_loader = DataLoader(test_dataset, batch_size=64, shuffle=False)

num_epochs = 100

def train(model, optimizer):
    model.train()

    total_loss = 0
    for data in train_loader:
        out = model(data)
        loss = loss_fn(out, data.y.unsqueeze(1))
        loss.backward()
        optimizer.step()
        optimizer.zero_grad()

def test(loader, model):
    model.eval()

    total_loss = 0
    with torch.no_grad():
        for data in loader:
            out = model(data)
            print("pred", len(out))
            print("actual", len(data.y.unsqueeze(1)))
            loss = loss_fn(out, data.y.unsqueeze(1))
            total_loss += loss.item() * data.num_graphs
    return total_loss / len(loader.dataset)

for epoch in range(num_epochs):
  train(model, optimizer)
  if (epoch + 1) % 10 == 0:
      train_loss = test(train_loader, model)
      test_loss = test(test_loader, model)
      print(f'Epoch: {epoch + 1:03d} | Train Loss: {train_loss:.4f} | Test Loss: {test_loss:.4f}')